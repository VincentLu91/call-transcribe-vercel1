<!DOCTYPE html>
<html>
  <head>
    <title>AssemblyAI Live Transcription</title>
  </head>
  <body>
    <h1>Live Transcription with Twilio and AssemblyAI</h1>
    <h3>
      Call your Twilio Number, start talking and watch your words magically
      appear.
    </h3>
    <div style="margin: 20px 0">
      <input
        type="tel"
        id="phone-number"
        placeholder="Enter phone number (e.g., 16471234567)"
        style="padding: 8px; margin-right: 10px"
      />
      <button onclick="makeCall()" style="padding: 8px 16px">Make Call</button>
    </div>
    <p id="transcription-container"></p>
    <!-- NEW: finalized paragraphs will accumulate here -->
    <div id="final-transcript" style="margin-top: 10px; line-height: 1.5"></div>

    <p id="recording-url"></p>

    <script>
      function makeCall() {
        try {
          const phoneNumber = document.getElementById("phone-number").value;
          if (!phoneNumber) {
            alert("Please enter a phone number");
            return;
          }
          console.log("init another call..");

          fetch("/make-outbounding-call", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ phoneNumber }),
          })
            .then((response) => {
              if (!response.ok) {
                // throw new Error("Failed to initiate call");
                console.error("Failed to initiate call");
              }
            })
            .catch((error) => {
              alert("Error: " + error.message);
            });
        } catch (error) {
          console.log("error47", error);
        }
      }

      document.addEventListener("DOMContentLoaded", (event) => {
        // In production on Vercel, use the VERCEL_URL environment variable
        const host = window.location.host;
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${host}`;

        let ws = new WebSocket(wsUrl);
        let nextOrder = 0; // local fallback when server doesn't provide an order_key
        let liveP = null;

        // NEW: stable rendering helpers
        const interimEl = document.getElementById("transcription-container");
        const finalEl = document.getElementById("final-transcript");
        const turnEls = new Map(); // order_key -> <p>

        function getOrCreateTurnEl(orderKey) {
          // Prefer server order_key; otherwise fall back to a local counter
          const key = Number.isFinite(Number(orderKey))
            ? String(orderKey)
            : String(nextOrder++);

          if (turnEls.has(key)) return turnEls.get(key);

          const p = document.createElement("p");
          p.dataset.order = key;
          p.id = `turn-${key}`;

          // APPEND-ONLY so nothing jumps around visually
          finalEl.appendChild(p);

          turnEls.set(key, p);
          return p;
        }

        function ping() {
          if (ws.readyState == WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "ping" }));
          } else {
            console.log("websocket is closed, stop ping.");
          }
        }

        ws.onopen = () => {
          console.log("WebSocket connected");
          keepAlive();
        };

        ws.onclose = () => {
          console.log("WebSocket closed. Reconnecting...");
          reconnect();
        };

        function keepAlive() {
          if (ws.readyState === WebSocket.OPEN) {
            console.log("Sending ping to server");
            ws.send(JSON.stringify({ event: "ping" }));
          }
          setTimeout(keepAlive, 20 * 1000); // Send every 50 seconds
        }

        function reconnect() {
          setTimeout(() => {
            ws = new WebSocket(wsUrl);
          }, 5000);
        }

        ws.onmessage = function (msg) {
          try {
            const data = JSON.parse(msg.data);

            if (data.event === "interim-transcription") {
              // Always render live text at the BOTTOM inside finalEl (no top container jump)
              if (!liveP) {
                liveP = document.createElement("p");
                liveP.id = "live-turn";
                finalEl.appendChild(liveP); // append-only, no reordering
              }
              liveP.textContent = (data.text || "").trim();

              // Determine order using server-provided order_key, else fall back locally
              const hasOrderFromServer = Number.isFinite(
                Number(data.order_key)
              );
              let order = hasOrderFromServer ? Number(data.order_key) : null;

              if (data.end_of_turn) {
                if (order == null) order = nextOrder++; // fallback order

                // Commit this live paragraph to a stable order key and clear "live"
                liveP.dataset.order = String(order);
                turnEls.set(String(order), liveP);
                liveP.id = ""; // it's no longer the live paragraph
                liveP = null; // next turn will create a new liveP
              }

              // If a later, formatted version of the same turn arrives, update in place
              if (data.turn_is_formatted) {
                if (order == null) order = Math.max(0, nextOrder - 1); // best-effort fallback
                const key = String(order);
                const p = turnEls.get(key) || getOrCreateTurnEl(order);
                p.textContent = (data.text || "").trim();
              }
            }

            if (data.event === "recording_completed") {
              const result = data.result;
              document.getElementById(
                "recording-url"
              ).innerHTML = `<a href="${result?.recordingUrl}">open url</a>`;
            }
          } catch (e) {
            console.log("ws.onmessage parse error", e);
          }
        };
      });
    </script>
  </body>
</html>
